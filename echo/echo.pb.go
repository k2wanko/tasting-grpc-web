// Code generated by protoc-gen-go. DO NOT EDIT.
// source: echo.proto

/*
Package echo is a generated protocol buffer package.

It is generated from these files:
	echo.proto

It has these top-level messages:
	Empty
	EchoRequest
	EchoResponse
	ServerStreamingEchoRequest
	ServerStreamingEchoResponse
	ClientStreamingEchoRequest
	ClientStreamingEchoResponse
*/
package echo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type EchoRequest struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *EchoRequest) Reset()                    { *m = EchoRequest{} }
func (m *EchoRequest) String() string            { return proto.CompactTextString(m) }
func (*EchoRequest) ProtoMessage()               {}
func (*EchoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type EchoResponse struct {
	Message      string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	MessageCount int32  `protobuf:"varint,2,opt,name=message_count,json=messageCount" json:"message_count,omitempty"`
}

func (m *EchoResponse) Reset()                    { *m = EchoResponse{} }
func (m *EchoResponse) String() string            { return proto.CompactTextString(m) }
func (*EchoResponse) ProtoMessage()               {}
func (*EchoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *EchoResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *EchoResponse) GetMessageCount() int32 {
	if m != nil {
		return m.MessageCount
	}
	return 0
}

// Request type for server side streaming echo.
type ServerStreamingEchoRequest struct {
	// Message string for server streaming request.
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
	// The total number of messages to be generated before the server
	// closes the stream; default is 10.
	MessageCount int32 `protobuf:"varint,2,opt,name=message_count,json=messageCount" json:"message_count,omitempty"`
	// The interval (ms) between two server messages. The server implementation
	// may enforce some minimum interval (e.g. 100ms) to avoid message overflow.
	MessageInterval int32 `protobuf:"varint,3,opt,name=message_interval,json=messageInterval" json:"message_interval,omitempty"`
}

func (m *ServerStreamingEchoRequest) Reset()                    { *m = ServerStreamingEchoRequest{} }
func (m *ServerStreamingEchoRequest) String() string            { return proto.CompactTextString(m) }
func (*ServerStreamingEchoRequest) ProtoMessage()               {}
func (*ServerStreamingEchoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ServerStreamingEchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ServerStreamingEchoRequest) GetMessageCount() int32 {
	if m != nil {
		return m.MessageCount
	}
	return 0
}

func (m *ServerStreamingEchoRequest) GetMessageInterval() int32 {
	if m != nil {
		return m.MessageInterval
	}
	return 0
}

// Response type for server streaming response.
type ServerStreamingEchoResponse struct {
	// Response message.
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *ServerStreamingEchoResponse) Reset()                    { *m = ServerStreamingEchoResponse{} }
func (m *ServerStreamingEchoResponse) String() string            { return proto.CompactTextString(m) }
func (*ServerStreamingEchoResponse) ProtoMessage()               {}
func (*ServerStreamingEchoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ServerStreamingEchoResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Request type for client side streaming echo.
type ClientStreamingEchoRequest struct {
	// A special value "" indicates that there's no further messages.
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *ClientStreamingEchoRequest) Reset()                    { *m = ClientStreamingEchoRequest{} }
func (m *ClientStreamingEchoRequest) String() string            { return proto.CompactTextString(m) }
func (*ClientStreamingEchoRequest) ProtoMessage()               {}
func (*ClientStreamingEchoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ClientStreamingEchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Response type for client side streaming echo.
type ClientStreamingEchoResponse struct {
	// Total number of client messages that have been received.
	MessageCount int32 `protobuf:"varint,1,opt,name=message_count,json=messageCount" json:"message_count,omitempty"`
}

func (m *ClientStreamingEchoResponse) Reset()                    { *m = ClientStreamingEchoResponse{} }
func (m *ClientStreamingEchoResponse) String() string            { return proto.CompactTextString(m) }
func (*ClientStreamingEchoResponse) ProtoMessage()               {}
func (*ClientStreamingEchoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ClientStreamingEchoResponse) GetMessageCount() int32 {
	if m != nil {
		return m.MessageCount
	}
	return 0
}

func init() {
	proto.RegisterType((*Empty)(nil), "grpc.testing.echo.Empty")
	proto.RegisterType((*EchoRequest)(nil), "grpc.testing.echo.EchoRequest")
	proto.RegisterType((*EchoResponse)(nil), "grpc.testing.echo.EchoResponse")
	proto.RegisterType((*ServerStreamingEchoRequest)(nil), "grpc.testing.echo.ServerStreamingEchoRequest")
	proto.RegisterType((*ServerStreamingEchoResponse)(nil), "grpc.testing.echo.ServerStreamingEchoResponse")
	proto.RegisterType((*ClientStreamingEchoRequest)(nil), "grpc.testing.echo.ClientStreamingEchoRequest")
	proto.RegisterType((*ClientStreamingEchoResponse)(nil), "grpc.testing.echo.ClientStreamingEchoResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EchoService service

type EchoServiceClient interface {
	// One request followed by one response
	// The server returns the client message as-is.
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// Sends back abort status.
	EchoAbort(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// One empty request, ZERO processing, followed by one empty response
	// (minimum effort to do message serialization).
	NoOp(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// One request followed by a sequence of responses (streamed download).
	// The server will return the same client message repeatedly.
	ServerStreamingEcho(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoClient, error)
	// One request followed by a sequence of responses (streamed download).
	// The server abort directly.
	ServerStreamingEchoAbort(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoAbortClient, error)
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the total number of messages as the result.
	ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_ClientStreamingEchoClient, error)
	// A sequence of requests with each message echoed by the server immediately.
	// The server returns the same client messages in order.
	// E.g. this is how the speech API works.
	FullDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_FullDuplexEchoClient, error)
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client messages and then returns the same
	// client messages one by one after the client half-closes the stream.
	// This is how an image recognition API may work.
	HalfDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_HalfDuplexEchoClient, error)
}

type echoServiceClient struct {
	cc *grpc.ClientConn
}

func NewEchoServiceClient(cc *grpc.ClientConn) EchoServiceClient {
	return &echoServiceClient{cc}
}

func (c *echoServiceClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := grpc.Invoke(ctx, "/grpc.testing.echo.EchoService/Echo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) EchoAbort(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := grpc.Invoke(ctx, "/grpc.testing.echo.EchoService/EchoAbort", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) NoOp(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/grpc.testing.echo.EchoService/NoOp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) ServerStreamingEcho(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[0], c.cc, "/grpc.testing.echo.EchoService/ServerStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceServerStreamingEchoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EchoService_ServerStreamingEchoClient interface {
	Recv() (*ServerStreamingEchoResponse, error)
	grpc.ClientStream
}

type echoServiceServerStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceServerStreamingEchoClient) Recv() (*ServerStreamingEchoResponse, error) {
	m := new(ServerStreamingEchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) ServerStreamingEchoAbort(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoAbortClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[1], c.cc, "/grpc.testing.echo.EchoService/ServerStreamingEchoAbort", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceServerStreamingEchoAbortClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EchoService_ServerStreamingEchoAbortClient interface {
	Recv() (*ServerStreamingEchoResponse, error)
	grpc.ClientStream
}

type echoServiceServerStreamingEchoAbortClient struct {
	grpc.ClientStream
}

func (x *echoServiceServerStreamingEchoAbortClient) Recv() (*ServerStreamingEchoResponse, error) {
	m := new(ServerStreamingEchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_ClientStreamingEchoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[2], c.cc, "/grpc.testing.echo.EchoService/ClientStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceClientStreamingEchoClient{stream}
	return x, nil
}

type EchoService_ClientStreamingEchoClient interface {
	Send(*ClientStreamingEchoRequest) error
	CloseAndRecv() (*ClientStreamingEchoResponse, error)
	grpc.ClientStream
}

type echoServiceClientStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceClientStreamingEchoClient) Send(m *ClientStreamingEchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceClientStreamingEchoClient) CloseAndRecv() (*ClientStreamingEchoResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ClientStreamingEchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) FullDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_FullDuplexEchoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[3], c.cc, "/grpc.testing.echo.EchoService/FullDuplexEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceFullDuplexEchoClient{stream}
	return x, nil
}

type EchoService_FullDuplexEchoClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type echoServiceFullDuplexEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceFullDuplexEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceFullDuplexEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) HalfDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_HalfDuplexEchoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EchoService_serviceDesc.Streams[4], c.cc, "/grpc.testing.echo.EchoService/HalfDuplexEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceHalfDuplexEchoClient{stream}
	return x, nil
}

type EchoService_HalfDuplexEchoClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type echoServiceHalfDuplexEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceHalfDuplexEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceHalfDuplexEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EchoService service

type EchoServiceServer interface {
	// One request followed by one response
	// The server returns the client message as-is.
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)
	// Sends back abort status.
	EchoAbort(context.Context, *EchoRequest) (*EchoResponse, error)
	// One empty request, ZERO processing, followed by one empty response
	// (minimum effort to do message serialization).
	NoOp(context.Context, *Empty) (*Empty, error)
	// One request followed by a sequence of responses (streamed download).
	// The server will return the same client message repeatedly.
	ServerStreamingEcho(*ServerStreamingEchoRequest, EchoService_ServerStreamingEchoServer) error
	// One request followed by a sequence of responses (streamed download).
	// The server abort directly.
	ServerStreamingEchoAbort(*ServerStreamingEchoRequest, EchoService_ServerStreamingEchoAbortServer) error
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the total number of messages as the result.
	ClientStreamingEcho(EchoService_ClientStreamingEchoServer) error
	// A sequence of requests with each message echoed by the server immediately.
	// The server returns the same client messages in order.
	// E.g. this is how the speech API works.
	FullDuplexEcho(EchoService_FullDuplexEchoServer) error
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client messages and then returns the same
	// client messages one by one after the client half-closes the stream.
	// This is how an image recognition API may work.
	HalfDuplexEcho(EchoService_HalfDuplexEchoServer) error
}

func RegisterEchoServiceServer(s *grpc.Server, srv EchoServiceServer) {
	s.RegisterService(&_EchoService_serviceDesc, srv)
}

func _EchoService_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.testing.echo.EchoService/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_EchoAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).EchoAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.testing.echo.EchoService/EchoAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).EchoAbort(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_NoOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).NoOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.testing.echo.EchoService/NoOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).NoOp(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_ServerStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ServerStreamingEchoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EchoServiceServer).ServerStreamingEcho(m, &echoServiceServerStreamingEchoServer{stream})
}

type EchoService_ServerStreamingEchoServer interface {
	Send(*ServerStreamingEchoResponse) error
	grpc.ServerStream
}

type echoServiceServerStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceServerStreamingEchoServer) Send(m *ServerStreamingEchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EchoService_ServerStreamingEchoAbort_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ServerStreamingEchoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EchoServiceServer).ServerStreamingEchoAbort(m, &echoServiceServerStreamingEchoAbortServer{stream})
}

type EchoService_ServerStreamingEchoAbortServer interface {
	Send(*ServerStreamingEchoResponse) error
	grpc.ServerStream
}

type echoServiceServerStreamingEchoAbortServer struct {
	grpc.ServerStream
}

func (x *echoServiceServerStreamingEchoAbortServer) Send(m *ServerStreamingEchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EchoService_ClientStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).ClientStreamingEcho(&echoServiceClientStreamingEchoServer{stream})
}

type EchoService_ClientStreamingEchoServer interface {
	SendAndClose(*ClientStreamingEchoResponse) error
	Recv() (*ClientStreamingEchoRequest, error)
	grpc.ServerStream
}

type echoServiceClientStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceClientStreamingEchoServer) SendAndClose(m *ClientStreamingEchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceClientStreamingEchoServer) Recv() (*ClientStreamingEchoRequest, error) {
	m := new(ClientStreamingEchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EchoService_FullDuplexEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).FullDuplexEcho(&echoServiceFullDuplexEchoServer{stream})
}

type EchoService_FullDuplexEchoServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type echoServiceFullDuplexEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceFullDuplexEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceFullDuplexEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EchoService_HalfDuplexEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).HalfDuplexEcho(&echoServiceHalfDuplexEchoServer{stream})
}

type EchoService_HalfDuplexEchoServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type echoServiceHalfDuplexEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceHalfDuplexEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceHalfDuplexEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EchoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.testing.echo.EchoService",
	HandlerType: (*EchoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _EchoService_Echo_Handler,
		},
		{
			MethodName: "EchoAbort",
			Handler:    _EchoService_EchoAbort_Handler,
		},
		{
			MethodName: "NoOp",
			Handler:    _EchoService_NoOp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerStreamingEcho",
			Handler:       _EchoService_ServerStreamingEcho_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ServerStreamingEchoAbort",
			Handler:       _EchoService_ServerStreamingEchoAbort_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ClientStreamingEcho",
			Handler:       _EchoService_ClientStreamingEcho_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FullDuplexEcho",
			Handler:       _EchoService_FullDuplexEcho_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "HalfDuplexEcho",
			Handler:       _EchoService_HalfDuplexEcho_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "echo.proto",
}

func init() { proto.RegisterFile("echo.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 370 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcd, 0x4b, 0xfb, 0x40,
	0x10, 0xed, 0xfe, 0x7e, 0xfd, 0xa0, 0x63, 0xfd, 0x5a, 0x2f, 0x21, 0x05, 0x2d, 0xeb, 0xc1, 0x78,
	0x30, 0x14, 0x05, 0x05, 0x6f, 0xb6, 0xd6, 0x8f, 0x83, 0x15, 0x5a, 0xbc, 0x78, 0x91, 0x34, 0x8c,
	0x69, 0x20, 0xcd, 0xc6, 0xcd, 0xa6, 0xe8, 0xc1, 0xab, 0xff, 0xb6, 0xb2, 0x4d, 0x0a, 0x42, 0x37,
	0x1a, 0xb1, 0xde, 0x3a, 0x33, 0x6f, 0xe7, 0xbd, 0xd7, 0x79, 0x04, 0x00, 0xdd, 0x31, 0xb7, 0x23,
	0xc1, 0x25, 0xa7, 0x9b, 0x9e, 0x88, 0x5c, 0x5b, 0x62, 0x2c, 0xfd, 0xd0, 0xb3, 0xd5, 0x80, 0xd5,
	0xa0, 0xd2, 0x9b, 0x44, 0xf2, 0x85, 0xed, 0xc1, 0x4a, 0xcf, 0x1d, 0xf3, 0x01, 0x3e, 0x25, 0x18,
	0x4b, 0x6a, 0x40, 0x6d, 0x82, 0x71, 0xec, 0x78, 0x68, 0x90, 0x16, 0xb1, 0xea, 0x83, 0x79, 0xc9,
	0x6e, 0xa0, 0x91, 0x02, 0xe3, 0x88, 0x87, 0x31, 0xe6, 0x23, 0xe9, 0x2e, 0xac, 0x66, 0x3f, 0x1f,
	0x5c, 0x9e, 0x84, 0xd2, 0xf8, 0xd7, 0x22, 0x56, 0x65, 0xd0, 0xc8, 0x9a, 0x5d, 0xd5, 0x63, 0x6f,
	0x04, 0xcc, 0x21, 0x8a, 0x29, 0x8a, 0xa1, 0x14, 0xe8, 0x4c, 0xfc, 0xd0, 0x2b, 0xa4, 0xa3, 0xd0,
	0x76, 0xba, 0x0f, 0x1b, 0x73, 0x90, 0x1f, 0x4a, 0x14, 0x53, 0x27, 0x30, 0xfe, 0xcf, 0x70, 0xeb,
	0x59, 0xff, 0x3a, 0x6b, 0xb3, 0x13, 0x68, 0x6a, 0x75, 0x7c, 0x67, 0x93, 0x1d, 0x83, 0xd9, 0x0d,
	0x7c, 0x0c, 0xe5, 0xcf, 0x0c, 0xb0, 0x0e, 0x34, 0xb5, 0xef, 0x32, 0xc2, 0x05, 0x7f, 0x64, 0xd1,
	0xdf, 0xe1, 0x7b, 0x25, 0x3d, 0x9b, 0x52, 0xee, 0xbb, 0x48, 0x2f, 0xa1, 0xac, 0x4a, 0xba, 0x6d,
	0x2f, 0x9c, 0xda, 0xfe, 0xa4, 0xca, 0xdc, 0xc9, 0x9d, 0x67, 0xec, 0x7d, 0xa8, 0xab, 0xfa, 0x6c,
	0xc4, 0x85, 0xfc, 0xf5, 0x36, 0x56, 0xa2, 0xa7, 0x50, 0xee, 0xf3, 0xdb, 0x88, 0x1a, 0x3a, 0xa8,
	0x0a, 0xa0, 0x99, 0x3b, 0xa1, 0x53, 0xd8, 0xd2, 0x5c, 0x86, 0x1e, 0x68, 0x1e, 0xe4, 0x27, 0xc9,
	0xb4, 0x8b, 0xc2, 0x53, 0xcd, 0x6d, 0x42, 0x5f, 0xc1, 0xd0, 0x00, 0xd2, 0xbf, 0xe4, 0x6f, 0xc9,
	0x59, 0xa9, 0x4d, 0x94, 0x6d, 0x4d, 0x3e, 0xb4, 0xcc, 0xf9, 0xf9, 0xd3, 0x32, 0x7f, 0x11, 0x3b,
	0x8b, 0xd0, 0x3b, 0x58, 0xbb, 0x48, 0x82, 0xe0, 0x3c, 0x89, 0x02, 0x7c, 0x5e, 0x4a, 0x9a, 0x2c,
	0xd2, 0x9e, 0xad, 0xbd, 0x72, 0x82, 0xc7, 0x25, 0xaf, 0xed, 0x54, 0xef, 0xcb, 0x6a, 0x30, 0xaa,
	0xce, 0x3e, 0x71, 0x47, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x21, 0x6d, 0xdd, 0x36, 0xf0, 0x04,
	0x00, 0x00,
}
